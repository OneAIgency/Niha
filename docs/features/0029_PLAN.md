# 0029 - Fix Critical DB Schema Issues

Fix the 4 critical issues identified in the DB Schema Audit (`docs/DB_SCHEMA_AUDIT.md`).

---

## Issue 1: DepositStatus.CONFIRMED — Dead Status in Service Layer

**Problem**: Two parallel deposit flows exist:
- **Normal flow** (deposit_service.py): PENDING → ON_HOLD → CLEARED
- **Direct create** (backoffice.py:689): → CONFIRMED (immediately credited)

The deposit_service **never** queries CONFIRMED, making direct-create deposits invisible to service-layer statistics. The count queries at `backoffice.py:1019` and `users.py:411` only count CONFIRMED, missing normal-flow CLEARED deposits.

**Fix**: Change direct-create deposits from CONFIRMED → CLEARED, since funds are immediately credited. Update count queries accordingly.

### Files to modify

**`backend/app/api/v1/backoffice.py`**
- `create_deposit()` (~line 689): Change `status=DepositStatus.CONFIRMED` → `status=DepositStatus.CLEARED`
- Also set `cleared_at` timestamp (same as `confirmed_at` pattern) for consistency
- `get_entity_balance()` (~line 1019): Change `Deposit.status == DepositStatus.CONFIRMED` → `Deposit.status == DepositStatus.CLEARED`

**`backend/app/api/v1/users.py`**
- `get_my_entity_balance()` (~line 411): Change `Deposit.status == DepositStatus.CONFIRMED` → `Deposit.status == DepositStatus.CLEARED`

**`backend/app/models/models.py`**
- Update `DepositStatus.CONFIRMED` comment from `"Backoffice confirmed receipt, now ON_HOLD"` to `"Legacy: backoffice direct confirm (use CLEARED instead)"`

**New migration** (optional, for existing data):
- `UPDATE deposits SET status = 'CLEARED' WHERE status = 'CONFIRMED'` to convert any existing CONFIRMED deposits
- Only needed if the live DB has CONFIRMED deposits (currently 0 deposit rows)

---

## Issue 2: Duplicate Migration Columns

**Problem**: `2026_02_02_add_random_interval.py` adds 4 execution columns to `auto_trade_rules`. The next migration `2026_02_02_auto_trade_execution.py` adds the **same 4 columns** again. Running `alembic upgrade head` on a fresh DB fails with `column already exists`.

Chain: `2026_02_02_auto_trade` → `2026_02_02_random_int` → `2026_02_02_execution` → `add_random_spread_cols`

**Fix**: Make `2026_02_02_auto_trade_execution.py` idempotent by checking if columns exist before adding them. This preserves the migration chain (no revision ID changes, no dependency rewiring) and works on both fresh and existing databases.

### Files to modify

**`backend/alembic/versions/2026_02_02_auto_trade_execution.py`**
- In `upgrade()`: Wrap each `op.add_column()` in a try/except that catches `sqlalchemy.exc.OperationalError` (column already exists), or use `op.execute()` to check `information_schema.columns` first
- Pattern:
  ```python
  from alembic import op
  import sqlalchemy as sa

  def column_exists(table, column):
      conn = op.get_bind()
      result = conn.execute(sa.text(
          "SELECT 1 FROM information_schema.columns "
          "WHERE table_name = :table AND column_name = :column"
      ), {"table": table, "column": column})
      return result.fetchone() is not None

  def upgrade():
      if not column_exists("auto_trade_rules", "max_price_deviation"):
          op.add_column(...)
      # ... same for other 3 columns
  ```

---

## Issue 3: counterparty_type Phantom Field

**Problem**: The `get_settlement_details()` endpoint docstring (settlement.py:157) documents `counterparty_type` in the example JSON response, but:
- The actual response code (lines 221-243) does NOT return it
- The `SettlementBatch` model has no such column
- The live DB has no such column
- It was only planned in an archived migration that was never applied

**Fix**: Remove `counterparty_type` from the docstring example. No code change needed since the actual response already omits it.

### Files to modify

**`backend/app/api/v1/settlement.py`**
- `get_settlement_details()` docstring (~line 157): Remove the `"counterparty_type": null,` line from the example JSON

---

## Issue 4: DepositStatus Enum Case Mismatch

**Problem**: Three different DepositStatus definitions exist with conflicting casing:

| Location | Values | Type |
|----------|--------|------|
| `models/models.py` | `"PENDING"`, `"CONFIRMED"`, etc. | SQLAlchemy Enum (DB truth) |
| `schemas/schemas.py` | `"pending"`, `"confirmed"`, etc. | Pydantic Enum |
| `api/v1/deposits.py` | `"pending"`, `"confirmed"`, etc. | Local API Enum |

The `deposit_to_response()` function extracts `.value` (UPPERCASE) into a `str` field, bypassing Pydantic validation. API query params accept lowercase. This creates a request/response inconsistency.

**Fix**: Unify all DepositStatus enums to UPPERCASE (matching the DB model, which is the source of truth). The model stores UPPERCASE, so all layers should expect UPPERCASE.

### Files to modify

**`backend/app/schemas/schemas.py`**
- `DepositStatus` enum: Change values from lowercase to UPPERCASE:
  ```python
  class DepositStatus(str, Enum):
      PENDING = "PENDING"
      CONFIRMED = "CONFIRMED"
      ON_HOLD = "ON_HOLD"
      CLEARED = "CLEARED"
      REJECTED = "REJECTED"
  ```

**`backend/app/api/v1/deposits.py`**
- `DepositStatusEnum` (~lines 63-68): Change values from lowercase to UPPERCASE:
  ```python
  class DepositStatusEnum(str, Enum):
      PENDING = "PENDING"
      CONFIRMED = "CONFIRMED"
      ON_HOLD = "ON_HOLD"
      CLEARED = "CLEARED"
      REJECTED = "REJECTED"
  ```
- `get_my_deposits()` (~line 379): The filter conversion `DepositStatus(status.value)` still works since values now match

**`backend/app/api/v1/backoffice.py`**
- Check all deposit status filter/query parameters — if any accept lowercase string values, update to UPPERCASE

**Frontend impact**: Check if the frontend sends deposit status filters. If so, update to send UPPERCASE values. Search for `pending`, `on_hold`, `cleared`, `confirmed`, `rejected` in deposit-related API calls.

---

## Execution Order

1. **Issue 3** first (docstring-only change, zero risk)
2. **Issue 2** next (migration idempotency, no runtime change)
3. **Issue 4** next (enum unification — test API filters after)
4. **Issue 1** last (behavioral change to deposit creation — most impactful)

Each issue can be a separate commit for clean rollback if needed.
