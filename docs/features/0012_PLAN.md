# 0012 – Approve contact & create user from contact request

Plan tehnic pentru fluxul „Approve & Create User”: aprobare cerere NDA → creare entity + user KYC (manual sau invitație) → actualizare status contact la KYC. Toate datele vin din DB/API; fără mock, demo sau cache.

---

## 1. Context

- **Surse:** `app_truth.md` (§8 Contact/NDA, Backoffice Contact Requests UI), `docs/commands/interface.md`, `frontend/docs/DESIGN_SYSTEM.md`, `.cursor/rules/niha-core.mdc`.
- **Scope:** Buton Approve pe cereri NDA → modal „Approve & Create User” → `POST /api/v1/admin/users/create-from-request` → user KYC cu entity nou, contact_request.user_role = KYC; opțional email invitație. Erori afișate corect în UI (standardizat + hint când există).

---

## 2. Fișiere și funcții relevante

| Zonă | Fișier | Elemente |
|------|--------|----------|
| **API** | `backend/app/api/v1/admin.py` | `create_user_from_contact_request` (POST `/users/create-from-request`), `get_admin_user`, broadcast `request_updated` / `user_created` |
| **Modele** | `backend/app/models/models.py` | `ContactRequest`, `ContactStatus`, `Entity`, `User`, `UserRole`, `Jurisdiction`, `KYCStatus` |
| **Schema** | `backend/app/schemas/schemas.py` | `ContactRequestResponse`, `ContactRequestUpdate` |
| **Excepții** | `backend/app/core/exceptions.py` | `handle_database_error`, `_collect_error_text`, `create_error_response` |
| **Securitate** | `backend/app/core/security.py` | `get_admin_user`, `hash_password` |
| **Email** | `backend/app/services/email_service.py` | `send_invitation`; MailConfig (Settings) pentru invitații |
| **Frontend API** | `frontend/src/services/api.ts` | `adminApi.createUserFromRequest`, axios interceptor (standardized error: `message`, `data`) |
| **UI** | `frontend/src/components/backoffice/ApproveInviteModal.tsx` | Modal approve, mod manual/invitație, formulare, extragere eroare din `message` / `data.detail` / `details.hint` |
| **Listă** | `frontend/src/components/backoffice/ContactRequestsTab.tsx` | Listă cereri, buton Approve → deschide `ApproveInviteModal`, `onApprove` |
| **Pagina** | `frontend/src/pages/BackofficeOnboardingPage.tsx` | Conține `ContactRequestsTab` pe `/backoffice/onboarding/requests` |
| **Realtime** | `frontend/src/hooks/useBackofficeRealtime.ts` | WebSocket backoffice; evenimente `request_updated`, `user_created` |
| **Tipuri** | `frontend/src/types/index.ts` | `ContactRequestResponse` (id, entity_name, contact_email, contact_name, position, …) |

---

## 3. Algoritm backend (create-from-request)

1. **Validare & auth:** Admin obligatoriu (`get_admin_user`). Parametri: `request_id`, `email`, `first_name`, `last_name`, `mode` ∈ {`manual`,`invitation`}, opțional `password`, `position` (toate Query).
2. **Contact request:** `SELECT` după `UUID(request_id)`. Lipsă → 404 `"Contact request not found"`.
3. **Email unic:** `SELECT` user cu `email.lower()`. Existent → 400 `"User with this email already exists"`.
4. **Mail config:** `SELECT` MailConfig ultima, pentru `invitation_token_expiry_days` (default 7) și (la mode invitație) trimitere email.
5. **Persistență (în try/except):**
   - Creează `Entity` cu `name=contact_request.entity_name`, `jurisdiction=Jurisdiction.OTHER`, `kyc_status=KYCStatus.PENDING`; `db.add` + `flush`.
   - **Manual:** `password` obligatoriu, len ≥ 8; altfel 400. User cu `password_hash`, `is_active=True`, `must_change_password=False`, `creation_method="manual"`.
   - **Invitație:** User cu `invitation_token`, `invitation_sent_at`, `invitation_expires_at` (now + expiry days), `is_active=False`, `must_change_password=True`, `creation_method="invitation"`.
   - User: `role=UserRole.KYC`, `entity_id=entity.id`, `created_by=admin_user.id`; `db.add(user)`.
   - `contact_request.user_role = ContactStatus.KYC`; `commit`; `refresh(user)`.
6. **Excepții:** `HTTPException` → rollback, re-raise. Orice altă excepție → rollback, `handle_database_error(e, "create user from contact request", logger)`.
7. **Invitație (după commit):** Doar dacă `mode == "invitation"`. Apelează `email_service.send_invitation(...)`. Eșecul la email se loghează; nu se anulează crearea userului.
8. **Broadcast:** `request_updated` (id, status KYC) și `user_created` (id, email, first_name, last_name, role) pe WebSocket backoffice.

---

## 4. Tratare erori DB (`handle_database_error`)

- **Input:** `e` (excepție), `operation` (string), logger. Text pentru matching: `str(e)` + `e.orig` / `e.__cause__` dacă există, lowercase.
- **Pattern-uri:**  
  - `unique constraint` / `duplicate key` / `uniqueviolation` → 409, „A record with this information already exists”.  
  - `foreign key constraint` / `foreign key` → 400, „Referenced record does not exist”.  
  - `not null constraint` / `not null` → 400, „Required field is missing”.  
  - `invalid input value for enum` → 400, mesaj pentru migrări (contactstatus/userrole, KYC etc.).  
- **Fallback:** 500, mesaj „An error occurred while {operation}”, `details`: `operation` + `hint` (prefix din `str(e)`, ~400 caractere).

---

## 5. Frontend: modal și consum erori

- **Deschidere:** Din `ContactRequestsTab`, buton Approve (doar pentru `status === 'NDA'` sau `'new'`) → `ApproveInviteModal` cu `contactRequest` și `onSuccess` care notifică parent (refresh/list update).
- **Date inițiale:** Email din `contactRequest.contact_email`; first/last din `contactRequest.contact_name` (split pe spațiu); position din `contactRequest.position`.
- **Submit:** `adminApi.createUserFromRequest(contactRequest.id, { email, first_name, last_name, mode, password?, position? })`. Parametri ca Query; axios exclude `undefined`.
- **Erori:** Interceptorul axios respinge cu obiect standardizat (`message`, `data`, `status`), fără `response`. Modalul citește: (1) `message` dacă string; (2) `data.detail` dacă string; (3) `data.detail[0].msg` la 422; (4) `data.detail.error` și `data.detail.details.hint` la răspuns `create_error_response`. Dacă există `hint`, se afișează și el (truncat ~150 caractere) după mesajul principal.
- **UI:** Design tokens (navy, emerald, red pentru erori); fără culori hardcodate. Conform `interface.md` și DESIGN_SYSTEM.

---

## 6. Migrări și enum-uri

- Enum `contactstatus` trebuie să conțină `KYC` (migrația `2026_01_29_user_contact_status_full_flow` adaugă `REJECTED`, `KYC`).  
- Enum `userrole` trebuie să conțină `KYC`.  
- Dacă migrările nu sunt aplicate, setarea `contact_request.user_role = KYC` poate genera „invalid input value for enum” → gestionată ca mai sus.

---

## 7. Specificații UI (când se schimbă modalul)

- Dacă se adaugă componente noi sau se reface layout-ul modalului, se folosesc specificațiile din `@interface.md` și `frontend/docs/DESIGN_SYSTEM.md`; verificare tokeni, accesibilitate, stări de încărcare/eroare.

---

## 8. Flux rezumat

1. Admin pe `/backoffice/onboarding/requests` → listă cereri (entity_name, contact_name, etc.).  
2. Approve pe cerere NDA → modal „Approve & Create User”.  
3. Admin alege manual vs invitație, completează email, first/last, position; la manual, parolă ≥ 8.  
4. Submit → `POST /admin/users/create-from-request` (Query).  
5. Backend: entity nou → user KYC → contact_request KYC → commit; la invitație, email; broadcast WS.  
6. La eroare: handle_database_error sau HTTPException → răspuns cu `detail` (string sau `{ error, code, details }`); frontend afișează mesaj (+ hint dacă există).  
7. La succes: modal închide, listă se actualizează (inclusiv prin WebSocket).
