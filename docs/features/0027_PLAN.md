# Plan 0027: Sursa diferenței de sold EUR – Dashboard vs Backoffice (Users → Assets)

## Context

Pentru același user (admin@nihaogroup.com / Nihao Group), cardul **Cash (EUR)** din Dashboard arată **€0.00** (cu „Total deposited: €16,999,650.00”), iar cardul **EUR Cash** din Backoffice → Users → [User] → tab Assets arată **€3,000,000.00**. Acest plan descrie sursa tehnică a diferenței, fără a schimba comportamentul existent.

## Cauza diferenței

Soldul EUR este obținut din **două API-uri cu logică diferită**:

| Unde se afișează | API folosit | Sursa EUR |
|-------------------|-------------|-----------|
| **Dashboard** – card „Cash (EUR)” | `GET /cash-market/user/balances` | **Doar** `EntityHolding` (rand EUR). Dacă lipsește sau e 0 → afișează 0. |
| **Backoffice** – tab Assets, card „EUR Cash” | `GET /backoffice/entities/{entity_id}/assets` | `EntityHolding` (EUR); **dacă e 0**, folosește **fallback** la `Entity.balance_amount`. |

Deci:

- **Dashboard**: citește exclusiv din `EntityHolding` (EUR). Nu folosește niciodată `Entity.balance_amount`.
- **Backoffice**: citește din `EntityHolding` (EUR), iar dacă acel sold e 0, folosește `Entity.balance_amount`.

Pentru entitatea Nihao Group, în practică:

- Nu există (sau e 0) sold EUR în `EntityHolding` → Dashboard = **€0.00**.
- `Entity.balance_amount` = 3,000,000 → Backoffice, datorită fallback-ului, afișează **€3,000,000.00**.

„Total deposited” de pe Dashboard vine din alt endpoint (`getMyEntityBalance` / `Entity.total_deposited`) și nu din soldul de EUR afișat pe card.

## Fișiere și funcții implicate

### 1. Dashboard – de unde vine Cash (EUR)

- **Frontend**: `frontend/src/pages/DashboardPage.tsx`
  - `eurBalance = entityAssets?.eurBalance ?? entityBalance?.balanceAmount ?? 0`
  - `entityAssets` este populat în `fetchBalance()` prin **`cashMarketApi.getUserBalances()`** (nu prin backoffice).
- **Frontend API**: `frontend/src/services/api.ts` – `cashMarketApi.getUserBalances()` → `GET /cash-market/user/balances`.
- **Backend**: `backend/app/api/v1/cash_market.py`
  - Ruta `GET /user/balances` (aprox. linia 836).
  - Apelează `get_entity_balance(db, current_user.entity_id, AssetType.EUR)`.
- **Backend – sursa efectivă a soldului**: `backend/app/services/order_matching.py`
  - Funcția `get_entity_balance()` (aprox. linia 166).
  - Face doar `select(EntityHolding)` pentru `entity_id` și `asset_type`; dacă nu există holding, returnează `Decimal("0")`. **Nu citește `Entity.balance_amount`.**

### 2. Backoffice – de unde vine EUR în tab Assets

- **Frontend**: `frontend/src/pages/UsersPage.tsx`
  - În `loadDeposits()`: `backofficeApi.getEntityAssets(entityId)` → setează `entityAssets.eurBalance`.
- **Frontend API**: `frontend/src/services/api.ts` – `backofficeApi.getEntityAssets(entityId)` → `GET /backoffice/entities/{entity_id}/assets`.
- **Backend**: `backend/app/api/v1/backoffice.py`
  - Ruta `get_entity_assets()` (aprox. liniile 1188–1259).
  - Citește toate `EntityHolding` pentru entitate și construiește `balances[AssetType.EUR]`.
  - **Fallback explicit** (aprox. liniile 1220–1222):
    - Dacă `balances[AssetType.EUR] == 0` și `entity.balance_amount` este setat, atunci `balances[AssetType.EUR] = entity.balance_amount`.
  - Răspunsul trimite `eur_balance=float(balances[AssetType.EUR])`.

### 3. Model de date

- **Entity** (`backend/app/models/models.py`): `balance_amount`, `total_deposited` (lifetime deposits).
- **EntityHolding**: solduri per tip de asset (EUR, CEA, EUA); cantitatea pentru EUR poate lipsi sau fi 0.

## Rezumat

| Aspect | Dashboard (Cash EUR) | Backoffice (EUR Cash) |
|--------|----------------------|------------------------|
| Endpoint | `/cash-market/user/balances` | `/backoffice/entities/{id}/assets` |
| Sursa EUR | Doar `EntityHolding` (EUR) | `EntityHolding` (EUR) + fallback la `Entity.balance_amount` |
| Când apare diferența | Când nu există/0 în EntityHolding EUR, dar `Entity.balance_amount` este setat | Fallback-ul face ca soldul să fie același cu `Entity.balance_amount` |

**Concluzie**: Diferența de sold EUR între cardul din Dashboard și cardul din Users → Assets pentru admin@nihaogroup.com vine din faptul că Dashboard folosește doar `EntityHolding` (EUR), iar Backoffice folosește și fallback-ul la `Entity.balance_amount`. Alinierea (fie prin același fallback pe dashboard, fie prin migrarea EUR în `EntityHolding` și renunțarea la fallback) poate fi tratată într-un plan / task separat.
