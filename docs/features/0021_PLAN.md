# 0021 – CEA and EUA Volumes as Integers Only

## Context

CEA and EUA are certificates traded in whole units only. There are no fractional certificates. The platform must treat all CEA volume and EUA volume as integer numbers everywhere: input validation, storage, API request/response, display, and calculations.

User requirements (verbatim):

- *"check all platform and make sure all cea volume and eau volume is always treated as integer numbers"*
- *"there no divisions of EUA and CEA certificated"*

---

## Source of truth

- **app_truth.md**: No explicit rule today. Add under §5 (Business Logic Truths) or a new bullet: **CEA and EUA volumes/quantities/amounts are whole numbers only; no fractional certificates.** All inputs for CEA/EUA quantity or amount must be validated as integers; all outputs must be serialized/displayed as integers.
- **EUR** amounts (e.g. balance_amount, deposit amount, order value in EUR) remain decimal where applicable; only **certificate quantities** (CEA count, EUA count) and **certificate amounts** in add-asset/transactions for CEA/EUA are integer.

---

## Scope

### In scope

- **Backend**: Schemas, API validation, and service layer for CEA/EUA quantities and amounts (order quantity, swap quantity, entity holding quantity for CEA/EUA, add-asset amount for CEA/EUA, marketplace/swap stats volumes, auto-trade quantities).
- **Frontend**: Types, API request payloads, form inputs (step/decimals), and display (formatQuantity or equivalent for certificate quantities) so users can only enter and see whole numbers for CEA/EUA.
- **app_truth.md**: Document the integer-only rule.

### Out of scope

- Changing **EUR** amounts to integers (deposits, balance_amount, order value in EUR, etc.).
- Database migration to change column types (e.g. `Numeric(18,2)` → `Numeric(18,0)` for certificate columns). Implementation uses application-layer validation and rounding; storage can remain Numeric(18,2) with values restricted to integers.
- Frozen files: only touch them if a bug fix is required for integer display/input; otherwise avoid refactors in frozen onboarding/login pages.

---

## Files and Functions to Change

### 1. app_truth.md

- In §5 (Business Logic Truths) or immediately after Swap Market Specifications, add: **CEA and EUA volumes/quantities/amounts are whole numbers only; no fractional certificates.** All API request fields and response fields representing CEA or EUA quantity/volume/amount must be integers; UI must accept and display only whole numbers for CEA/EUA.

---

### 2. Backend – Schemas (`backend/app/schemas/schemas.py`)

| Area | Current | Change |
|------|---------|--------|
| **Certificate / Trade / Swap (legacy)** | `CertificateCreate.quantity`, `CertificateResponse.quantity`, `MarketplaceListing.quantity`, `TradeCreate.quantity`, `TradeResponse.quantity`, `SwapCreate.quantity`, `SwapResponse.quantity` — all `float` | Use `int` (or `conint(ge=1)` where positive required). Add field validators that reject non-integer or use a custom type that coerces/validates to int. |
| **PortfolioSummary** | `total_eua: float`, `total_cea: float` | `int` (or float that is always rounded to int in response). |
| **CEA Cash Market** | `OrderCreate.quantity`, `OrderResponse.quantity` / `filled_quantity` / `remaining_quantity`, `OrderBookLevel.quantity` / `cumulative_quantity`, `OrderFill.quantity`, `OrderPreviewRequest.quantity`, `OrderPreviewResponse.total_quantity` / `quantity_requested`, `MarketOrderRequest.quantity`, `LimitOrderRequest.quantity`, `OrderExecutionResponse.total_quantity`, `OrderExecutionResponse.certificate_balance`, `MarketDepthPoint.cumulative_quantity`, `CashMarketTradeResponse.quantity`, `MarketStatsResponse.volume_24h` | All CEA quantities: require/return integers (int or validators that ensure whole number). |
| **Add-asset / Entity** | `AddAssetRequest.amount` (used for EUR, CEA, EUA) | When `asset_type` is CEA or EUA, validate `amount` is integer (e.g. validator on schema that checks when asset_type in (CEA, EUA)). Option: separate optional `amount_cea`/`amount_eua` or keep single `amount` with conditional validator. |
| **EntityHoldingResponse** | `quantity: float` | When representing CEA/EUA, return int (validator or serializer). |
| **AssetTransactionResponse** | `amount`, `balance_before`, `balance_after: float` | When transaction is for CEA/EUA, values must be integers (response serialization). |
| **EntityAssetsResponse** | `cea_balance`, `eua_balance: float` | Integer for CEA/EUA. |
| **Market Maker** | `MarketMakerResponse.cea_balance`, `eua_balance` (Decimal), `MarketMakerTransactionResponse.amount`, `balance_after` | When certificate_type is CEA/EUA: integer (or Decimal with scale 0). |
| **Swap API (swaps.py)** | `CreateSwapRequest.quantity`, `get_available_swaps` min_quantity/max_quantity, `calculate_swap` quantity query, `CreateSwapOfferRequest.eua_quantity` | All quantities: int / integer validation. |
| **Auto-trade** | `fixed_quantity`, `min_quantity`, `max_quantity` (Decimal) for CEA/EUA rules | Validate as integers (e.g. no fractional part). |

Implementation approach: use `conint(ge=0)` or `conint(ge=1)` where appropriate and/or Pydantic validators that cast float to int or reject non-integer. For request bodies that share `amount` between EUR and CEA/EUA (e.g. AddAssetRequest), add a validator that when `asset_type in (CEA, EUA)` checks `amount == int(amount)` and optionally coerce to int.

---

### 3. Backend – API endpoints

| File | Function / Endpoint | Change |
|------|---------------------|--------|
| **backoffice.py** | `add_asset_to_entity` | When `asset_request.asset_type` is CEA or EUA: validate `asset_request.amount` is integer (e.g. reject 1.5). Before updating holding, round amount to int (e.g. `int(amount_abs)`). Return success message with integer amount. |
| **backoffice.py** | Entity assets / transactions responses | Serialize `quantity`, `amount`, `balance_before`, `balance_after` as integers when asset/certificate type is CEA or EUA. |
| **swaps.py** | `CreateSwapRequest`, `get_available_swaps`, `calculate_swap`, `get_swap_stats` | Validate `quantity`, `min_quantity`, `max_quantity`, `eua_quantity` as integers. In responses (e.g. my swaps, calculator output), return `quantity` and equivalent output quantity as integers. `total_eua_volume`, `total_cea_volume` in stats: return int (e.g. 0 not 0.0). |
| **swaps.py** | `CreateSwapOfferRequest` / create swap offer | Validate `eua_quantity` is integer. |
| **cash_market.py** | Order create, preview, execute, orderbook, trades | All quantity-related request params and response fields for CEA: validate as integer; serialize as int (e.g. `int(round(float(order.quantity)))` for responses). |
| **marketplace.py** | `get_marketplace_overview` | `total_cea_volume`, `total_eua_volume`: return as integers (e.g. `int(round(total_cea_volume))`, `0` not `0.0`). |

---

### 4. Backend – Services

| File | Change |
|------|--------|
| **balance_utils.py** | When updating EntityHolding for CEA or EUA, ensure `amount` and resulting `quantity` are integer (e.g. use `Decimal(int(amount))` or quantize to 0 decimal). |
| **backoffice.py** (add-asset) | When writing to EntityHolding for CEA/EUA, set `holding.quantity` to integer (e.g. `Decimal(int(balance_after))`). |
| **order_matching.py** / **limit_order_matching.py** | Already use integer match quantity where commented. Ensure any new order or fill quantity for CEA is stored as integer (Decimal with no fractional part). |
| **liquidity_service.py** | Any CEA/EUA quantities passed to orders or returned to API: integer. |
| **market_maker_service.py** | CEA/EUA balances and transaction amounts: treat as integer in responses and when updating. |
| **auto_trade_executor.py** | Already quantizes swap EUA quantity to `Decimal("1")`. Ensure CEA cash market order quantities are also integer (e.g. quantize to 1). All `fixed_quantity`, `min_quantity`, `max_quantity` used for CEA/EUA: integer. |
| **swap_service.py** (if exists) | Swap request/order quantities: integer. |
| **settlement_service.py** / **settlement_processor.py** | SettlementBatch.quantity and any CEA/EUA amounts: integer when persisting or returning. |

---

### 5. Backend – Models

- No schema migration required. Keep `Numeric(18, 2)` (or current type) for `EntityHolding.quantity`, `Order.quantity`, `CashMarketOrder.quantity`, `CashMarketTrade.quantity`, `SwapRequest.quantity`, etc. Application code must only assign integer values (or Decimal with scale 0) for CEA/EUA columns. Optional: add a check in services that when certificate_type is CEA or EUA, quantity is whole number before commit.

---

### 6. Frontend – Types (`frontend/src/types/index.ts`)

- Types that represent CEA/EUA quantity or volume (e.g. order quantity, swap quantity, entity cea_balance/eua_balance, totalCeaVolume/totalEuaVolume, transaction amount for CEA/EUA): document that they are integers; API responses should be parsed as numbers but displayed with 0 decimals. No need to change to `number` to a different type; ensure consumers treat them as whole numbers and format with 0 decimals.

---

### 7. Frontend – Display

| File | Change |
|------|--------|
| **utils/index.ts** | `formatQuantity`: when used for CEA/EUA certificate quantities, show 0 decimals. Options: (a) add `formatCertificateQuantity(value)` that formats with `maximumFractionDigits: 0`, and use it wherever CEA/EUA quantity is displayed; or (b) change `formatQuantity` to always use 0 decimals (may affect other uses; check FundingPage, etc.). Prefer (a) or a parameter like `decimals?: number` defaulting to 0 for certificate quantities. |
| **BalanceCards.tsx**, **MarketMakersList.tsx**, **MarketMakerDetailsTab.tsx**, **MarketMakerTransactionsTab.tsx** | Use certificate-aware formatting for CEA/EUA (e.g. `formatCertificateQuantity` or `formatQuantity(x, 0)`). |
| **CashMarketProPage.tsx** | Already uses `formatQuantity` and `Math.round(trade.quantity)`. Ensure all CEA quantities displayed use 0 decimals. |
| **DashboardPage.tsx** | Order quantity, swap quantity, settlement quantity: display as integer (formatNumber with 0 decimals or formatCertificateQuantity). |
| **UserDetailModal.tsx** | For CEA/EUA asset transaction amount: display as integer (already uses `maximumFractionDigits: 0` for non-EUR; keep consistent). |
| **CreateLiquidityPage.tsx** | `eua_quantity`: accept and display only integers (e.g. `Math.round(euaQuantity)` before submit; display with 0 decimals). |
| **CeaSwapMarketPage.tsx** | Swap quantity inputs and outputs: integer only; display with 0 decimals. |
| **OrderBookRow.tsx**, **UserOrderEntryModal.tsx**, **InlineOrderForm.tsx** | CEA quantity: 0 decimals in display; quantity input step=1, no decimals. |

---

### 8. Frontend – Inputs and API calls

| File | Change |
|------|--------|
| **TransactionForm.tsx** | Already uses `decimals={0}` for amount. Ensure submitted value is integer (e.g. `Math.floor(amountNum)` or `parseInt(amount, 10)` before calling API). |
| **ProfilePage.tsx** | When crediting CEA or EUA, send integer (e.g. `Math.floor(amount)`). |
| **CreateLiquidityPage.tsx** | Send `eua_quantity` as integer (e.g. `Math.round(euaQuantity)`). |
| **Cash market order submission** | When sending `quantity` for CEA orders, send integer. |
| **Swap create/calculator** | Send and display quantity as integer. |
| **api.ts** | Types/comments: document that CEA/EUA quantity and volume fields are integers. When building request bodies, ensure number values for those fields are integers. |

---

### 9. Tests

- **Backend**: Add or adjust tests for add-asset (CEA/EUA amount must be integer; 400 for fractional). Swap create/calculator: fractional quantity rejected or coerced per spec. Cash market order: quantity integer validation. Marketplace/swaps stats: total_cea_volume, total_eua_volume are integers.
- **Frontend**: Optionally add a test that formatCertificateQuantity (or formatQuantity with 0 decimals) outputs no decimal part for CEA/EUA; and that TransactionForm for CEA/EUA submits integer.

---

## Algorithm / validation summary

1. **Request validation (backend)**  
   For any field representing CEA or EUA quantity or amount: accept only whole numbers. If float is sent, either reject with 422 (e.g. "CEA quantity must be an integer") or coerce with truncation/round and document behavior. Recommended: coerce to int (e.g. `int(round(x))`) for positive quantities and validate `>= 0` or `>= 1` as applicable.

2. **Persistence**  
   When writing to DB for CEA/EUA quantity or amount columns, use `Decimal(int(value))` or `quantize(Decimal("1"), ROUND_DOWN)` so no fractional part is stored.

3. **Response serialization**  
   When returning CEA/EUA quantities or volumes (orderbook, balances, trades, stats), serialize as integer (e.g. `int(round(float(model.quantity)))` or ensure Pydantic schema uses int).

4. **Frontend**  
   Inputs: `step={1}`, `decimals={0}` for CEA/EUA quantity/amount. On submit, send `Math.floor` or `Math.round` to integer. Display: always 0 decimal places for CEA/EUA quantities and volumes.

---

## Phases

- **Phase 1 – Data layer and SSOT**: Update app_truth.md; add schema validators and response types (int) for CEA/EUA in backend schemas; ensure API request validation and response serialization for CEA/EUA quantities/amounts/volumes.
- **Phase 2 – Backend services and endpoints**: Apply integer validation and rounding in backoffice add-asset, swaps, cash_market, marketplace; balance_utils and other services that write CEA/EUA quantities.
- **Phase 3 – Frontend**: formatCertificateQuantity (or 0 decimals) for display; integer-only inputs and payloads for CEA/EUA; update types/comments in api.ts and relevant components.

Phases 2 and 3 can be parallelized after Phase 1 is agreed.
