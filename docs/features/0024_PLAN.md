# 0024 – Admin role simulation (floating window)

## Descriere

Pentru utilizatorul cu rol **ADMIN**, când este autentificat în platformă, există o **fereastră floating** din care adminul poate **simula orice rol** dintre cele existente în platformă, pe pagina pe care se află. Adminul poate modifica oricând rolul simulat; el păstrează tot timpul rolul real **ADMIN**. Scopul este **testare** (a redirecturilor, a conținutului vizibil per rol, a flow-urilor per rol).

Simularea este **doar pe frontend**: request-urile API rămân cu utilizatorul real (ADMIN); nu se schimbă token-ul sau rolul pe backend.

## Roluri existente (sursă: `UserRole`)

Din `frontend/src/types/index.ts`: `ADMIN`, `MM`, `NDA`, `REJECTED`, `KYC`, `APPROVED`, `FUNDING`, `AML`, `CEA`, `CEA_SETTLE`, `SWAP`, `EUA_SETTLE`, `EUA`. Toate acestea trebuie să poată fi selectate în fereastra de simulare.

## Fișiere relevante

- **Stare și rol efectiv**
  - `frontend/src/stores/useStore.ts` – adăugare stare pentru rol simulat (ex.: `simulatedRole: UserRole | null`) și eventual setter; doar pentru ADMIN.
  - Funcție helper (nouă, ex. în `frontend/src/utils/` sau în store): `getEffectiveRole(user, simulatedRole) => UserRole`: dacă `user?.role === 'ADMIN'` și `simulatedRole != null` returnează `simulatedRole`, altfel `user.role`. Aceasta este singura sursă pentru „rolul folosit la redirect și la deciziile de UI” când admin simulează.

- **Rutare și guard-uri**
  - `frontend/src/App.tsx` – în `AuthGuard`: folosire rol efectiv (din helper) în loc de `user.role` pentru: verificare REJECTED, `allowedRoles`, `blockRoles`, redirect la `getPostLoginRedirect`. Comportament: când admin nu simulează, rol efectiv = ADMIN (acces total); când simulează, redirecturile și blocajele se aplică ca pentru rolul simulat.
  - `frontend/src/App.tsx` – `CatchAllRedirect`: folosire `getPostLoginRedirect` cu un user „virtual” care are `role: effectiveRole` (sau apelare `getPostLoginRedirect` cu obiect care expune rol efectiv), astfel încât adminul care simulează să fie redirecționat ca rolul respectiv.
  - `frontend/src/utils/redirect.ts` – `getPostLoginRedirect(user)`: funcția primește un obiect cu `role`; dacă în App se trimite deja user cu rol efectiv, nu e nevoie să schimbe semnătura; altfel, expunere funcție/helper care primește direct `role: UserRole` pentru redirect (pentru cazul „user efectiv” cu rol simulat).

- **Fereastra floating**
  - Componentă nouă (ex.: `frontend/src/components/admin/RoleSimulationFloater.tsx` sau similar). Vizibilă **doar** când `user?.role === 'ADMIN'`. Poziție: fixed (ex. colț bottom-right), z-index sub modale (ex. sub `z-50`), deasupra conținutului. Conține: selector (dropdown/select) cu toate valorile din `UserRole`; opțiune „Fără simulare” / „Clear” care setează `simulatedRole = null`. Design: token-uri din `frontend/docs/DESIGN_SYSTEM.md` și `frontend/src/styles/design-tokens.css` (navy, emerald, fără slate/gray).
  - Montare: în `App.tsx` ca sibling la `<Routes>` (ex. fragment cu Routes + componentă condiționat de `isAuthenticated && user?.role === 'ADMIN'`), astfel încât floatarea rămână montată și la redirect (când adminul simulează NDA și e dus la `/onboarding`); nu în interiorul unui route protejat care s-ar demonta.

- **UI care depinde de rol**
  - `frontend/src/components/layout/Header.tsx` – afișează `user?.role`. Opțional: când există simulare, afișare „ADMIN (simulând: X)” sau doar rol efectiv pentru claritate; dacă se afișează doar rol efectiv, trebuie folosit `getEffectiveRole`.
  - `frontend/src/pages/DashboardPage.tsx` – folosește `user?.role` (ex. AML, funded roles). Înlocuire cu rol efectiv acolo unde decizia de UI e „ce vede utilizatorul pe pagină” (ex. card AML, vizibilitate secțiuni).
  - Orice alt loc care folosește `user.role` pentru **afișaj sau logică de pagină** (nu pentru API) trebuie trecut la rol efectiv acolo unde scopul este „comportament ca și cum userul ar avea acel rol”. Fișiere identificate: `FundingPage.tsx` (isAdmin), `ProfilePage.tsx`, `UsersPage.tsx` (acces la backoffice). Decizie: pentru backoffice (Users, Settings etc.) se poate păstra verificarea pe rol real (ADMIN), astfel încât simularea să nu ascundă butoanele de admin; pentru Dashboard, Header, redirecturi, se folosește rol efectiv. Planul trebuie să specifice: **redirecturi și conținut de pagină (Dashboard, etc.) = rol efectiv; acces la backoffice (rute /backoffice, Settings, Users) = rol real ADMIN**, astfel încât adminul să poată oricând accesa backoffice chiar dacă simulează NDA.

## Consistență cu app_truth și design

- **app_truth.md** §8: User role este SSOT; aici rolul „efectiv” este doar un override de prezentare/redirect pentru ADMIN, nu schimbă `User.role` în backend.
- **Design**: Fereastra floating folosește token-uri Tailwind (navy-*, emerald-*, etc.), clase din `design-tokens.css`, fără culori hardcodate. Opțional: specificații UI scurte conform `docs/commands/interface.md` pentru poziție, z-index și accesibilitate (focus, aria-label).

## Algoritm

1. **Stare**: `simulatedRole: UserRole | null` în store (persistență opțională în sessionStorage, doar pentru sesiune).
2. **Rol efectiv**: `getEffectiveRole(user, simulatedRole)` → dacă user ADMIN și simulatedRole setat, returnăm simulatedRole; altfel `user.role`.
3. **AuthGuard**: După verificare autentificat și user existent, se calculează `effectiveRole = getEffectiveRole(user, simulatedRole)`. Verificări REJECTED, allowedRoles, blockRoles și redirecturi se fac cu `effectiveRole`. Excepție: rutele strict admin (ex. backoffice, Settings) pot verifica explicit `user.role === 'ADMIN'` ca să nu fie ascunse când adminul simulează NDA/KYC (sau se permite acces la backoffice doar pe baza rolului real – detaliu de implementare).
4. **getPostLoginRedirect**: La redirect (în AuthGuard și CatchAllRedirect) se apelează cu un obiect care are `role: effectiveRole`, astfel încât adminul care simulează NDA să meargă la `/onboarding`, etc.
5. **Floating window**: Render condiționat `user?.role === 'ADMIN'`. Selector cu toate valorile UserRole + „Fără simulare”. La schimbare se actualizează `simulatedRole` în store. UI compact (dropdown + label „Simulare rol (test)” sau similar).

## Faze (implementare logică)

1. **Stare și helper**: Adăugare `simulatedRole` în store (sau store dedicat) + `getEffectiveRole(user, simulatedRole)` și export.
2. **Rutare**: Integrare rol efectiv în AuthGuard și în CatchAllRedirect / getPostLoginRedirect.
3. **Fereastra floating**: Componentă nouă, montare în App, doar pentru ADMIN, design tokens.
4. **Pagini**: Înlocuire `user.role` cu rol efectiv în Header și în paginile unde se dorește „vederea ca rol X” (ex. Dashboard); păstrare verificare `user.role === 'ADMIN'` pentru backoffice și Settings.

## Clarificări incluse

- Adminul are **tot timpul** rol real ADMIN; simularea este doar pentru testare pe pagină (redirecturi, conținut).
- Poate **modifica oricând** rolul simulat din fereastra floating.
- **Toate** rolurile din platformă (UserRole) sunt disponibile pentru simulare.
