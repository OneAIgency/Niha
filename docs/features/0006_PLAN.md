# Plan: NDA form – date salvate, notificare backoffice, badge, modal

## Context

Utilizatorul cere asigurarea că:

1. **Toate datele din formularul NDA** (inclusiv fișierul PDF încărcat) sunt salvate în baza de date.
2. **Apare o notificare** în legătură cu o nouă cerere la `http://localhost:5173/backoffice/onboarding/requests`.
3. **Iconița / badge-ul** (ex. „2 items” în SubSubHeader) este actualizat când există cereri noi.
4. **Toate elementele din form** sunt afișate în modalul de vizualizare (ContactRequestViewModal).

Formularul NDA este cel de pe LoginPage (mode `nda`): „Submit your signed NDA to request access”, cu câmpurile Entity Name, Corporate Email, Your Name, Position in Entity, Upload Signed NDA (PDF), butoane SUBMIT NDA și Back. Modalul este ContactRequestViewModal („Contact request details”, cu POSITION, STATUS etc.).

## Surse de adevăr

- **App truth**: `app_truth.md` – stack, porturi, design system, backoffice routing (Onboarding la `/backoffice/onboarding/requests`), SubSubHeader cu `.subsubheader-nav-badge`.
- **Design system**: `frontend/docs/DESIGN_SYSTEM.md`, `frontend/src/styles/design-tokens.css` – tokeni navy/emerald, fără culori hardcodate.
- **Interfață**: `docs/commands/interface.md` – cerințe interfață.

## Fișiere relevante

### Backend

- `backend/app/api/v1/contact.py` – `create_nda_request` (POST `/contact/nda-request`): primește Form (entity_name, contact_email, contact_name, position, file), validează PDF, salvează în DB (ContactRequest cu nda_file_name, nda_file_data, submitter_ip), broadcast WebSocket `new_request`.
- `backend/app/models/models.py` – modelul `ContactRequest` (entity_name, contact_email, contact_name, position, request_type, nda_file_name, nda_file_data, nda_file_mime_type, submitter_ip, status, created_at, reference, notes).
- `backend/app/api/v1/admin.py` – `get_contact_requests` (răspuns cu toate câmpurile incl. nda_file_name, submitter_ip), `download_nda_file` (GET NDA), endpoint `/admin/contact-requests/{request_id}/nda`.
- `backend/app/schemas/schemas.py` – ContactRequestCreate, ContactRequestResponse, ContactRequestUpdate.

### Frontend – formular NDA

- `frontend/src/pages/LoginPage.tsx` – state (entity, email, contactName, position, ndaFile), `handleNDA`, `handleFileChange`, trimitere prin `contactApi.submitNDARequest` (FormData: entity_name, contact_email, contact_name, position, file). Câmpurile form: Entity Name, Corporate Email, Your Name, Position in Entity, Upload Signed NDA (PDF).

### Frontend – API și tipuri

- `frontend/src/services/api.ts` – `contactApi.submitNDARequest` (FormData cu entity_name, contact_email, contact_name, position, file), `adminApi.downloadNDA`, `adminApi.getContactRequests`.
- `frontend/src/types/index.ts` – NDARequest, ContactRequestResponse (id, entity_name, contact_email, contact_name, position, reference, request_type, nda_file_name, submitter_ip, status, notes, created_at).
- `frontend/src/types/backoffice.ts` – ContactRequest (același set de câmpuri pentru backoffice).

### Frontend – backoffice și realtime

- `frontend/src/hooks/useBackofficeRealtime.ts` – fetch inițial `getContactRequests`, WebSocket; la mesaj `new_request` apelează `addContactRequest(message.data)`.
- `frontend/src/stores/useStore.ts` – BackofficeState: `contactRequests`, `addContactRequest` (prepend în listă), `updateContactRequest`.
- `frontend/src/pages/BackofficeOnboardingPage.tsx` – derivează `contactRequests` din store, `contactRequestsCount = contactRequests.length`, SubSubHeader cu badge `count` pentru path `requests`; randare ContactRequestsTab și (în tab) deschidere ContactRequestViewModal.

### Frontend – modal și listă

- `frontend/src/components/backoffice/ContactRequestViewModal.tsx` – afișează DataRow pentru: Entitate, Nume, Email, Position, Reference, Request type, Status, Data completării, IP (cu Lookup), Notes; plus secțiune NDA document (nda_file_name + buton download).
- `frontend/src/components/backoffice/ContactRequestsTab.tsx` – listă contact requests, deschide ContactRequestViewModal la selectare, primește `onDownloadNDA`, `onIpLookup`.

## Ce este de verificat / completat

### 1. Date formular + PDF salvate în DB

- **Backend**: `create_nda_request` salvează deja entity_name, contact_email, contact_name, position, nda_file_name, nda_file_data (binary), nda_file_mime_type, submitter_ip, request_type="nda", status=NEW. Nu se folosesc mock/cache.
- **Frontend**: LoginPage trimite toate câmpurile + fișierul prin FormData; API folosește același nume de câmpuri.
- **Plan**: Verificare că răspunsul de la POST `/contact/nda-request` și schema ContactRequestResponse conțin toate câmpurile necesare pentru listă/modal (id, created_at, nda_file_name etc.). Dacă lipsește ceva în răspuns (ex. created_at), extindere schema/răspuns backend.

### 2. Notificare nouă cerere la backoffice/onboarding/requests

- **Flux actual**: După create_nda_request, backend face `backoffice_ws_manager.broadcast("new_request", {...})`. useBackofficeRealtime ascultă și apelează `addContactRequest(newRequest)`, deci lista din ContactRequestsTab se actualizează fără refresh.
- **Plan**: Confirmare că payload-ul WebSocket `new_request` conține toate câmpurile pe care ContactRequestResponse le așteaptă (id, entity_name, contact_email, contact_name, position, request_type, nda_file_name, submitter_ip, status, created_at). Dacă frontend așteaptă snake_case, verificare că backend trimite snake_case (sau că frontend transformă). Opțional: notificare toast/banner când `new_request` sosește (ex. „New contact request received”), fără a schimba restul fluxului.

### 3. Badge (iconița) actualizat

- **Flux actual**: Badge-ul din SubSubHeader pentru „Contact Requests” este `count = path === 'requests' ? contactRequestsCount : ...`, unde `contactRequestsCount = contactRequests.length`. contactRequests vine din store; la `addContactRequest` store-ul se actualizează și componenta se re-renderează cu noul count.
- **Plan**: Verificare că după `addContactRequest` nu există deduplicare greșită (ex. același id adăugat de două ori). În store, `addContactRequest` face prepend fără verificare id; dacă același request ar putea veni atât din fetch cât din WS, considerare deduplicare în addContactRequest (ex. dacă id există, înlocuire sau skip) ca să nu apară count dublat. Asigurare că badge-ul afișează același număr ca numărul de rânduri din listă.

### 4. Toate elementele din form afișate în modal

- **Form NDA**: Entity Name → entity_name; Corporate Email → contact_email; Your Name → contact_name; Position in Entity → position; PDF → nda_file_name (și download).
- **Modal**: ContactRequestViewModal afișează deja Entitate (entity_name), Nume (contact_name), Email (contact_email), Position (position), Request type, Status, Data completării (created_at), IP (submitter_ip), NDA document (nda_file_name + download). Reference și Notes sunt opționale (editabile din backoffice).
- **Plan**: Confirmare că toate câmpurile din formularul NDA au corespondent în modal (entity_name, contact_name, contact_email, position, nda_file_name). Nu se elimină Reference/Notes din modal; acestea rămân pentru cereri „join” sau pentru completări ulterioare. Etichete: păstrare „Position” în modal (sau aliniere la „Position in Entity” dacă se dorește consistență cu formularul).

## Algoritm / ordine de implementare

1. **Verificare backend**: Răspuns POST `/contact/nda-request` și payload WebSocket `new_request` conțin id, entity_name, contact_email, contact_name, position, request_type, nda_file_name, submitter_ip, status, created_at. Completare orice câmp lipsă în broadcast sau în ContactRequestResponse.
2. **Verificare frontend NDA**: LoginPage trimite entity_name, contact_email, contact_name, position, file; fără mock; mesaje de eroare clare la validare.
3. **Verificare store + badge**: addContactRequest – opțional deduplicare după id (replace dacă există) ca să evite count dublat; badge = contactRequests.length.
4. **Verificare modal**: Lista de DataRow-uri din ContactRequestViewModal acoperă entity_name, contact_name, contact_email, position, request_type, status, created_at, submitter_ip, notes, reference, nda_file_name; NDA download funcțional.
5. **Opțional**: Toast sau banner „New contact request” la primire mesaj WebSocket `new_request` pe pagina de requests.

## Note

- Nu se folosesc mock data, demo data sau cache; toate datele vin din API/DB.
- Design: toate componentele implicate (LoginPage NDA form, ContactRequestsTab, ContactRequestViewModal, SubSubHeader badge) respectă design system (tokeni navy/emerald, fără hex).
- Pentru specificații UI detaliate (ex. text exact notificare) se poate folosi `@interface.md` sau un fișier UI spec în docs/features.
