# Plan: NDA flow, Approve & Invite, and configurable Mail/Auth in Settings

## Description

Clarify and implement the user-category flow: **NDA** (user submits form + PDF on login page) → appears in backoffice **Contact Requests** for verification → admin **Approve & Invite** → user becomes **PENDING**. Approve & Invite is done by "admin local" in one of two ways: (1) **authorize user with credentials** — email from NDA form + password set manually by admin; (2) **invite user** — application sends an invitation email to the NDA form email using a mail service. Mail and authentication are to be **configurable in Settings**, where admin can configure mail server parameters, templates, verification methods, and authentication.

Existing behaviour to preserve: NDA form on login page (`POST /contact/nda-request`), contact requests list and View/Approve/Reject/Delete in backoffice, `POST /admin/users/create-from-request` with `mode=manual` (password set by admin) or `mode=invitation` (invitation email). After create-from-request the user is created with **role PENDING** and contact request status ENROLLED. New work: add **configurable mail and auth in Settings** (mail server params, templates, verification, authentication) and wire the application to use this configuration when sending invitation (and optionally other) emails.

## User requirements (verbatim)

- "NDA dupa ce un utilizator a introdus datele si a urcat pdf in formularul nda de pe pagina login si apare pentru verificare in backoffice contact requests."
- "Dupa ce admin approve & invite, utilizatorul devine PENDING."
- "approve and invite se poate face de catre admin local, adica autorizand userul cu credentialele email din formularul de NDA, o parola setata de admin manual sau alegand invite user."
- "in acest caz aplicatia va trimite un mail de invitatie catre adresa de mail mentionata in formularul de nda folosind un serviciu de mail si de autentificare pe care il vom include in aplitie la settings unde admin poate configura parametrii serverului de mail, templates, modalitati de verificare si de autentificare."

## Current state (no change to flow)

- **NDA form**: Login page NDA form submits to `POST /contact/nda-request` (backend `backend/app/api/v1/contact.py`). Request is stored with `request_type="nda"`, appears in backoffice Contact Requests via `GET /admin/contact-requests` and WebSocket `new_request`.
- **Approve & Invite**: Backoffice Onboarding → Contact Requests → "Approve & Invite" opens `ApproveInviteModal` (`frontend/src/components/backoffice/ApproveInviteModal.tsx`). Modal supports two modes: **Invite user** (sends invitation email) and **Set password manually** (admin sets password). Call: `adminApi.createUserFromRequest(contactRequest.id, { email, first_name, last_name, mode: 'invitation' | 'manual', password?, position? })` → `POST /admin/users/create-from-request` (`backend/app/api/v1/admin.py`). User is created with `role=UserRole.PENDING`, entity from contact request; contact request status → ENROLLED. For `mode=invitation`, backend generates invitation token and calls `email_service.send_invitation(...)`.
- **Email today**: `backend/app/services/email_service.py` uses `settings.RESEND_API_KEY` and `settings.FROM_EMAIL` from `backend/app/core/config.py` (env). Invitation link and templates are hardcoded (e.g. `http://localhost:5173/setup-password?token=...`, 7-day expiry). No UI to configure mail or auth.

## Scope of this feature

- **Leave unchanged**: NDA form, contact request storage, backoffice list/modal, create-from-request API contract (manual vs invitation), user creation with role PENDING, auth endpoints `GET /auth/validate-invitation/{token}` and `POST /auth/setup-password`.
- **Add**: Storage and API for **mail and auth settings** (admin-configurable). **Settings UI** (mail server parameters, templates, verification methods, authentication options). **Email service** (and any auth-related behaviour) must use the stored configuration when present, with fallback to current env-based behaviour so existing deployments keep working.

## Files and functions to change

### Backend

| File | Change |
|------|--------|
| `backend/app/models/models.py` | Add model(s) for stored mail/auth configuration (e.g. `MailConfig` or key-value `AppSetting`). Fields to support: mail server (host, port, use_tls, username, password or secret ref), from_address, optional provider override (e.g. Resend vs SMTP), invitation template (subject, body or key), invitation link base URL, token expiry days; auth/verification options (e.g. magic link vs password, 2FA flags) if in scope. |
| `backend/alembic/versions/` | New migration: create table(s) for mail/auth settings. Down revision: `2026_01_29_baseline`. |
| `backend/app/schemas/schemas.py` | Pydantic schemas for mail config (and auth config) read/update, including validation (e.g. URL format, port range). |
| `backend/app/core/config.py` | No removal of `RESEND_API_KEY` / `FROM_EMAIL`; keep as defaults/fallback when no stored config or when stored config says "use env". |
| `backend/app/api/v1/admin.py` | New endpoints (admin-only): e.g. `GET /admin/settings/mail`, `PUT /admin/settings/mail`; optionally `GET/PUT /admin/settings/auth` or combined settings. Use `get_admin_user` dependency. Validate and persist to new table(s). |
| `backend/app/services/email_service.py` | Refactor to read mail config from DB (or injected config service). When sending invitation (and optionally magic link, contact follow-up, etc.): use stored SMTP/Resend params, from_address, and invitation template/link base URL/expiry from config when present; otherwise use current env and hardcoded templates. No mock or in-memory-only config — must load from database. |

### Frontend

| File | Change |
|------|--------|
| `frontend/src/pages/SettingsPage.tsx` | Add a **Mail & Auth** (or **Email & Authentication**) section/tab alongside existing Scraping sources. Admin can view and edit: mail server (host, port, TLS, credentials placeholder or masked), from address, provider (Resend vs SMTP if both supported), invitation template (subject/body or template key), invitation link base URL, token expiry; verification/authentication options as defined in API. Use design tokens and existing Card/Button/Input patterns; no hard-coded colors. |
| `frontend/src/services/api.ts` | Add `adminApi.getMailSettings()`, `adminApi.updateMailSettings(payload)` (and auth if separate). All data from real API. |
| `frontend/src/types/index.ts` (or backoffice/settings type file) | Types for mail (and auth) settings matching backend schemas. |

### Documentation

| File | Change |
|------|--------|
| `app_truth.md` | §4 Integrations: note that mail can be configured via Settings (stored in DB) with env fallback; §8 or new subsection for Settings page: Mail & Auth configuration (admin-only). |
| `docs/api/BACKOFFICE_API.md` or new `docs/api/SETTINGS_API.md` | Document `GET/PUT /admin/settings/mail` (and auth if present): request/response shapes, validation rules. |

## Data and behaviour

- **No mock or demo data**: Mail/auth settings are read from and written to the database via the new admin API. If no row exists, backend returns defaults (or empty) and email service falls back to env (current behaviour).
- **Invitation flow**: When admin chooses "Invite user" and submits ApproveInviteModal, backend still creates user with PENDING and invitation token; when sending the invitation email, backend uses stored mail config (SMTP or Resend params, from_address, template, base URL for setup-password link, expiry) when available, else current Resend + env.
- **Verification/authentication**: "modalitati de verificare si de autentificare" means admin can configure how users verify (e.g. magic link vs password-only) and auth options. Scope in this plan: define in data model and Settings UI the placeholders (e.g. flags or dropdowns) for verification method and auth method; actual switching of auth flows (e.g. disable magic link) can be a follow-up if not trivial.

## Algorithm (invitation send path)

1. Admin clicks Approve & Invite, selects "Invite user", submits. Frontend calls `POST /admin/users/create-from-request` with `mode=invitation`.
2. Backend creates entity (if needed), user with `role=PENDING`, `invitation_token`, `invitation_expires_at` (e.g. now + configured days or default 7), contact request → ENROLLED.
3. Backend loads mail config from DB (if table exists and has row; else use env defaults).
4. Backend calls email service to send invitation: recipient = user.email, first_name, token. Email service: if stored config present, use its SMTP/Resend, from_address, and template (subject/body with placeholder for setup URL); build setup URL from stored base URL + token; else use current Resend + hardcoded template and `http://localhost:5173/setup-password?token=...`.
5. Frontend Settings: admin loads mail (and auth) settings via GET, edits form, submits PUT; backend validates and saves to DB. Next invitation (and optionally other emails) use updated config.

## Phases

1. **Phase 1 – Data layer**  
   Add model(s) and migration for mail (and auth) settings. Add Pydantic schemas. No API or UI yet; email service still env-only.

2. **Phase 2A – Backend API and email service**  
   Implement GET/PUT admin settings endpoints, load/save to DB. Refactor `EmailService` to accept or load stored config and use it when sending (invitation first; other emails optional in same phase). Keep env fallback when no config.

3. **Phase 2B – Frontend Settings UI**  
   Settings page: Mail & Auth section, forms bound to real API, types aligned with backend. No mock data.

## References

- `app_truth.md` §4 (Email/Resend), §8 (Backoffice), §9 (Design system).
- `backend/app/api/v1/admin.py` — `create_user_from_contact_request`, `email_service.send_invitation`.
- `backend/app/services/email_service.py` — `send_invitation`, `_send_email` (Resend).
- `frontend/src/components/backoffice/ApproveInviteModal.tsx` — mode manual vs invitation, `adminApi.createUserFromRequest`.
- `frontend/src/pages/SettingsPage.tsx` — current structure (scraping sources); add Mail & Auth section.
- `frontend/docs/DESIGN_SYSTEM.md`, `.cursor/rules/niha-core.mdc` — tokens and components for new Settings UI.
